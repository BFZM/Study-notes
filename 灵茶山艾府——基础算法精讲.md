---
typora-root-url: ./灵茶山艾府——基础算法精讲.assets
---

# 基础算法精讲———灵茶山艾府

## 学习情况汇总：

##### 1.双指针：

- [ ] 课后题：
- [x] 复习一轮：9月13日
- [x] 复习二轮：9月22日
- [ ] 重难点总结

##### 2.二分查找：

- [ ] 课后题：
- [x] 复习一轮：9月13日
- [x] 复习二轮：9月22日
- [ ] 重难点总结

##### 3.链表：

- [ ] 课后题：
- [x] 复习一轮：9月13日
- [x] 复习二轮：9月22日
- [ ] 重难点总结

##### 4.二叉树：

- [ ] 课后题：
- [x] 复习一轮：9月20日
- [ ] 复习二轮
- [ ] 重难点总结

##### 5.回溯：

- [ ] 课后题：
- [x] 复习一轮：9月20号
- [ ] 复习二轮
- [ ] 重难点总结

##### 6.动态规划：

- [ ] 课后题：
- [ ] 复习二轮
- [ ] 重难点总结

## 01.相向双指针：

### 167.两数之和：

主要算法原理，对于有序数列，首尾相加的结果与target进行比较，如果比target小左指针右移，比target大右指针左移

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        right = len(numbers) - 1
        left = 0
        while left < right: # 题目要求不能使用重复元素，所以当left = right时应终止循环
            if numbers[left]+numbers[right] > target:
                right -= 1
            elif numbers[left]+numbers[right] < target:
                left += 1
            else:
                return [left + 1, right + 1]
```

### 15.三数之和：

此题是在上一题中升级出来的，可以将其中一个数看成target的序列

**跟着教程写的：**

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        res = []
        for i in range(0,n - 2):

            if nums[i]==nums[i-1] and i > 0:
                continue
            if nums[i]+nums[i+1]+nums[i+2] > 0 :
                break
            if nums[i]+nums[-2]+nums[-1] < 0:
                continue
            j = i + 1
            k = n - 1
            while k > j:
                if nums[i] + nums[j] + nums[k] > 0:
                    k -= 1
                elif nums[i] + nums[j] + nums[k] < 0:
                    j += 1
                else:
                    res.append([nums[i], nums[j], nums[k]])
                    j += 1
                    while nums[j] == nums[j-1] and k > j:
                        j += 1
                    k -= 1
                    while nums[k] == nums[k + 1] and k > j:
                        k -= 1
        return res
```

**第二遍自己写出现的问题：**

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 因为题中强调三元组的顺序不重要，所以可以先进行排序，按照有序数列计算
        nums.sort()
        n = len(nums)
        ans = []

        # 首先要确定i
        for i in range(0, n-2): # 没考虑到给j，k留位置只能循环到n-2
            if nums[i]==nums[i-1] and i > 0: # 没有添加约束条件i>0，这样在i = 0时会报错
                continue
                
            # 三数之和的两个优化：
            # 1 如果i和最大的两个数之和依然小于0
            if nums[i] + nums[-1] +nums[-2] < 0 :
                continue 
            # 2 如果i和i+1和i+2之和大于0
            if nums[i] + nums[i+1] +nums[i+2] > 0:
                break
                
            j = i + 1
            k = n - 1
            while j < k:
                if nums[i] + nums[j] +nums[k] > 0:
                    k -= 1
                elif nums[i] + nums[j] +nums[k] < 0:
                    j += 1
                else:
                    ans.append([nums[i],nums[j],nums[k]])
                    j += 1 #这个地方没有想清楚如何让循环能继续进行下去
                    while nums[j] == nums[j - 1] and k > j: # 没有添加约束条件k>j
                        j += 1
                    k -= 1
                    while nums[k] == nums[k + 1] and k > j:
                        k -= 1
        return ans
```



## 02.相向双指针

### 11.盛最多水的容器：

贪心算法，从最外侧两个板向中间移动，如果想要容量增大，则要保证高度比原来的高，由于水桶的容量是靠短板控制，所以贪心规则是不断将短板向中间移动，直到两块板相遇，记录过程中的所有的容量，求出最大值。

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 贪心算法，每次都是将短的板向内移动，因为水的高度由短板决定，移动长板只能减小长度，高度减小或不变。
        i = 0
        j = len(height) - 1
        ans = 0
        cup = 0
        while i < j:
            cup = min(height[i],height[j]) * (j - i)
            if height[i] < height[j]:
                i += 1
            else:
                j -= 1
            if ans < cup:
                ans = cup
        return ans
```

### *42.接雨水问题

![image-20230913103040049](G:\Typora-user-images\image-20230913103040049.png)

**跟着教程写的**

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        
        # 未进行空间优化
        n = len(height)
        pre_list = [0] * n
        pre_list[0] = height[0]
        for i in range(1, n):
            pre_list[i] = max(pre_list[i-1], height[i])
        
        suf_list = [0] * n
        suf_list[-1] = height[-1]
        for i in range(n-2, -1, -1):
            suf_list[i] = max(suf_list[i+1], height[i])

        ans = 0
        for pre, suf, high in zip(pre_list, suf_list, height):
            ans += min(pre,suf) - high
        return ans
```

**第二次自己写的,ak**

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        
        # 每个桶对应的容量是取决于其左右两侧最短的板决定的，设置两个数组，分别代表左右两侧桶壁的高度
        n = len(height)
        right_height = [0] * n
        left_height = [0] * n
        max_right_height = 0
        max_left_height = 0

        # 历遍左侧桶高
        for i in range(n):
            if height[i] > max_left_height :
                left_height[i] = height[i]
                max_left_height = height[i]
            else:
                left_height[i] = max_left_height
        
        # 历遍右侧桶高
        for i in range(n-1, -1, -1):
            if height[i] > max_right_height :
                right_height[i] = height[i]
                max_right_height = height[i]
            else:
                right_height[i] = max_right_height
        
        ans = 0
        # 汇总雨量
        for lef, rig, h in zip(left_height, right_height, height):
            ans += min(lef, rig) - h
        return ans
```

**空间优化**

将left与right数组合并，双指针分别从两头进行遍历，每次移动小的桶高，直至左右指针汇合

![image-20230913103454703](G:\Typora-user-images\image-20230913103454703.png)

**自己写的为通过的代码**:思路已经掌握，在转化为代码语言的过程中出现了死循环

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        right = n - 1
        left = 0
        ans = 0
        max_left = height[0]
        max_right = height[-1]
        while left <= right:
            while left <= right and max_left > max_right :
                ans += max_right - height[right]
                right -= 1
                if max_right < height[right]:
                    max_right = height[right]
            while left <= right and max_left < max_right:
                ans += max_left - height[left]
                left += 1
                if max_left < height[left]:
                    max_left = height[left]
        return ans
```

**按照视频写的代码**

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        right = n - 1
        left = 0
        ans = 0
        max_left = 0
        max_right = 0
        while left <= right:
            max_left = max(max_left, height[left])
            max_right = max(max_right, height[right])
            if max_left < max_right:
                ans += max_left - height[left]
                left += 1
            else:
                ans += max_right - height[right]
                right -= 1
        return ans
```



## 03.同向双指针——滑动窗口题

### 209.长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和==大于等于== `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

解题思路，

![image-20230913111547843](G:\Typora-user-images\image-20230913111547843.png)

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        ans = n + 1 # 要注意ans的取值，因为取最小所以ans应初始化inf
        s = 0
        left = 0
        
        for right, x in enumerate(nums):
            s += x
            while s >= target:
                ans = min(ans, right-left+1)
                s -= nums[left]
                left += 1
        return ans if ans <= n else 0
```

### 713.乘积小于k的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回子数组内所有元素的乘积严格==小于== `k` 的连续子数组的数目。

<img src="G:\Typora-user-images\image-20230913144713321.png" alt="image-20230913144713321"  />

自己练习写回溯算法：

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        def dfs(chioces:list[int],states:list[int],res:List[int],i):
            # 边界条件
            temp =0
            for m in range(len(states)):
                temp *= states[m]
            if i == len(nums) or temp>=k :
                res.append(states)
                return
            

            states.append(chioces[i])
            dfs(chioces,states,res,i+1)
            states.pop()
            dfs(chioces,states,res,i)
        res = []
        states = []
        dfs(nums, states, res, 0)
        return res
```

双指针法：

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        # 从l,r中间的乘积是小于k的话
        # 则每个元素的子集都是小于k的，所以情况一共加了r - l + 1
        if k <= 1:
            return 0
        res = 0
        left = 0
        total = 1
        for right in range(len(nums)):
            total *= nums[right]

            while total >= k :# 解答为什么这个地方不用写left>=right，因为当其相等的时候total=1不可能比k大所以相当于条件重复可以不写
                total /= nums[left]
                left += 1
            res += right - left + 1
        return res
```

### ==3.无重复的最长子串：==

给定一个字符串 `s` ，请你找出其中==不含有==重复字符的 **最长子串** 的长度。

![image-20230913152050768](G:\Typora-user-images\image-20230913152050768.png)

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 设置一个hash表
        dect1 = Counter()# 怎么设置这个hasp表是关键，直接用dect1={}在执行dect1[c]+=1时会报错
        left = 0
        res = 0
        n = len(s)
        if n == 1:
            return 1
        
        for right, c in enumerate(s):
            dect1[c] += 1
            while dect1[c] > 1:
                dect1[s[left]] -= 1
                left += 1
            res = max(res, right-left+1)# 注意res什么时候写在while循环里面，当题目要求和while循环后条件一致时，res写在while循环中，否则写在while循环外面
        return res

```

## 04.二分查找

### 34.在排序数组中查找元素的第一个和最后一个位置

~~~java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int start = lowerBound(nums, target); // 选择其中一种写法即可
        if (start == nums.length || nums[start] != target)
            return new int[]{-1, -1};
        // 如果 start 存在，那么 end 必定存在
        int end = lowerBound(nums, target + 1) - 1;
        return new int[]{start, end};
    }
    public int lowerBound(int[] nums, int target) {
        /**
         * 数组nums非递减顺序排列
         * 使用闭区间书写
         */
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int mid = (left + right) / 2;
            if(nums[mid] < target){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return left;
    }
}
~~~

<font color=#f00>**保持[left,right]中的所有元素都是未知的，在区间外的所有元素都是已知的**</font>

</![image-20230913160047194](G:\Typora-user-images\image-20230913160047194.png)

![image-20230913171041095](G:\Typora-user-images\image-20230913171041095.png)

![image-20230913160421697](G:\Typora-user-images\image-20230913160421697.png)

<font color =#00f>二分查找思路关键，每时每刻都是在一个闭区间进行处理，如果是使用双闭区间，就要将左边的指针移动到mid+1或者将右边的指针移动到mid-1，如果是左闭右开区间就是要把右边的指针移动到mid，左边指针移动到mid-1；如果是双开区间就是把左边的指针移动到mid，右边的指针移动到mid</font>

#### 双闭区间二分查找写法：

```python
def lower_bound1(self, nums: List[int], target: int) -> int:
        # 在闭区间上[left,right]，找到>=target位置的第一个索引
        n = len(nums)
        left, right = 0, n-1
        while left <= right: # 原则上保证区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1    # 要保证区间外全部为已知大小关系的元素所以 现在未知区间的为[left,right]        
            elif nums[mid] >= target: #因为要找≥target的元素所以当所查找到的mid值为target时应将相等的部分放到未知区间的右边，所以这里写等于
                right = mid - 1
        # 这里要确定循环不变量，每次都是把小于target的元素放在集合的左边及left的左边，所以left代表第一个≥target的值
        return left
```

#### 左闭右开区间二分查找写法：

```python
def lower_bound2(self, nums: List[int], target: int) -> int:
        # 在左闭右开区间上[left,right)，找到>=target位置的第一个索引
        n = len(nums)
        left, right = 0, n # 为保证左闭右开区间所以要将右指针放到nums的有边界的外面
        while left < right: # 原则上保证区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid + 1    # 要保证区间外全部为已知大小关系的元素所以 现在未知区间的为[left,right）        
            elif nums[mid] >= target: #因为要找≥target的元素所以当所查找到的mid值为target时应将相等的部分放到未知区间的右边，所以这里写等于
                right = mid #因为右边界为开区间，所以集合外部已知排序的部分应为[right，end]，所以right=mid
                
        # 这里要确定循环不变量，每次都是把小于target的元素放在集合的左边及left的左边，所以left和right重合都代表第一个≥target的值        
        return left
```

#### 双开区间二分查找写法：

```python
def lower_bound3(self, nums: List[int], target: int) -> int:
        # 在开区间上(left,right)，找到>=target位置的第一个索引
        n = len(nums)
        left, right = -1, n # 为保证开区间所以要将左右指针放到nums的有边界的外面
        while left + 1 < right: # 原则上保证区间不为空
            mid = left + (right - left) // 2
            if nums[mid] < target:
                left = mid     # 要保证区间外全部为已知大小关系的元素所以 现在未知区间的为（left,right）        
            elif nums[mid] >= target: #因为要找≥target的元素所以当所查找到的mid值为target时应将相等的部分放到未知区间的右边，所以这里写等于
                right = mid #因为右边界为开区间，所以集合外部已知排序的部分应为[right，end]，所以right=mid
                
        # 这里要确定循环不变量，left代表第一个大于等于target的值的左边的一个，right代表第一个大于等于target的值        
        return right
```

![image-20230913165426333](G:\Typora-user-images\image-20230913165426333.png)

==四种不等号的转换，本题采用≥，变成＞可以按≥x+1；变成＜可以按≥x查找的左边的数；变成≤可以按＞x查找左边的数==



## 05.二分查找

### 162.寻找峰值：

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

![image-20231126194844336](./灵茶山艾府——基础算法精讲.assets/image-20231126194844336.png)

***对于有二阶段性的问题都可以用二分查找***

思路：红蓝染色法，先规定一个峰顶的位置（可以把峰顶设置为左边染红色，可以把峰顶设置为右边染蓝色）,主要是通过比较中间值mid与mid+1的值确定，mid是属于红色还是蓝色区域，直到所有的区域都被染色

<font color=#f00>**最关键的思想：目标峰顶和右侧都是染成蓝色**</font>

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        # 红蓝染色法，将峰顶和峰顶的右侧全都染成蓝色，将峰顶的左侧全都归到红色区，利用开区间进行二分查找
        n = len(nums)
        right = n - 1
        left = -1
        while left + 1 < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid
        return right
```

**第二次自己写的代码，利用闭区间进行二分查找**

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        n = len(nums)
        right = n - 2
        left = 0
        target = nums[-1]
        while left <= right:
            mid = (left + right) >> 1
            if nums[mid] > nums[mid + 1]:
                right = mid - 1
            else:
                left = mid + 1
        return left
```

<font color =#00f>java版代码</font>

~~~java
class Solution {
    public int findPeakElement(int[] nums) {
        int i = 0, j = nums.length - 2;
        while(i <= j){
            int mid = (i + j) >>> 1;
            if(nums[mid] < nums[mid + 1]){
                i = mid + 1;
            }else{
                j = mid - 1;
            }
        }
        return i;
    }
}
~~~



### 153.寻找旋转排序数组中的端点

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 本题采用左开右闭区间，注意将mid与right进行比较，根据数形结合可以得到以下二分查找算法，因为是左开右闭区间所以最后左右指针汇合在一起返回left或right都可以
        left = 0 
        right = len(nums)-1 # 直接将nums末尾元素添加到蓝区
        while left < right:
            mid = (left + right)>> 1 # 位运算符在二进制中向右移一位相当于整除2
            if nums[mid] > nums[right]:
                left = mid+1
            else:
                right = mid 
        return nums[left]
```



### 33.搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

![image-20230914173242896](G:\Typora-user-images\image-20230914173242896.png)

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # 目标是将target及其右侧的部分染成蓝色，用左闭右开区间进行判断返回right或left都可以
        def is_blue(i) -> bool:
            end = nums[-1]
            mid = nums[i]
            if nums[i] > end:
                return target <= mid and target > end
            else:
                return target <= mid or target > end
        
        left = 0
        right = len(nums) 
        while right > left:
            mid = left + (right - left) // 2
            if is_blue(mid):
                right = mid
            else:
                left = mid + 1
        return -1 if right == len(nums) or nums[right] != target else right   
```



## 06.反转链表

### 206.翻转列表：

思路将链表的后节点的指针指向上一节点，将原来的首节点指向空，注意应设置三个临时变量来记录变化过程中的前后节点以及next指针。

![image-20230914092356178](G:\Typora-user-images\image-20230914092356178.png)

![image-20230914091310346](G:\Typora-user-images\image-20230914091310346.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        pre = None
        cur = head
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
```

### 92.反转链表II

![image-20230914092734940](G:\Typora-user-images\image-20230914092734940.png)

![image-20230914094100173](G:\Typora-user-images\image-20230914094100173.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        # 为保证left等于0时反转链表前有节点保证算法顺利运行，添加哨兵节点demmy
        demmy = ListNode(next = head)
        p0 = demmy # 为什么要多用一个p0，demmy相当于链表上一个固定的新节点，p0相当于从demmy位置初始化的一个新指针，不断往后移动直到找到反转链表的前一个位置
        for _ in range(left-1): #为了找到p0哨兵节点的位置，放在需要反转的链表段的第一个节点的前一个位置，题目中left不是集合中的下标是下标+1
            p0 = p0.next #p0从哨兵节点不断变为下一个节点
        
        # 和之前的反转链表算法一致
        cur = p0.next
        pre = None
        for _ in range(right - left + 1):
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        
        # 接下来将反转段的链表的新的头结点与尾节点与原链表进行连接
        p0.next.next = cur #p0.next相当于图片中的p0
        p0.next = pre
        return demmy.next
```

### 25.K个一组翻转链表：

循环的判断逻辑，求出链表总长，每次循环在总长的基础上减去k，在每次循环结束后pre指向翻转部分的最后一个节点，cur指向下一组需要翻转的链表第一个节点，所以每翻转完一组后，要将p0.next指向pre，另外在未翻转之前的p0.next就是下次翻转的p0的位置，所以应该提前保存nxt=p0.next,并将下次p0赋值为nxt。

![image-20230914095716901](G:\Typora-user-images\image-20230914095716901.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        # 先求出链表的长度
        n = 0
        cur = head
        while cur:
            n += 1
            cur = cur.next
        
        # 为保证left等于0时反转链表前有节点保证算法顺利运行，添加哨兵节点demmy
        demmy = ListNode(next = head)
        p0 = demmy
        
        while n >= k:
            n -= k
            # 和之前的反转链表算法一致
            cur = p0.next
            pre = None
            for _ in range(k):
                nxt = cur.next
                cur.next = pre
                pre = cur
                cur = nxt
            
            # 接下来将反转段的链表的新的头结点与尾节点与原链表进行连接
            p0.next.next = cur
            nxt = p0.next #这道题的关键，要在哨兵节点转换前先进行一次保留，因为原来哨兵节点在经过翻转后正好是下一次翻转段的前一节点位置
            p0.next = pre
            p0 = nxt
        return demmy.next
```

## 07.环形链表

### 876.链表的中间结点

![image-20230914101655387](G:\Typora-user-images\image-20230914101655387.png)

```python
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
# 注意遇到的有意思的事，如果在while中条件写fast.next and fast: 则无法通过程序。
```

### 141.环形链表I

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast = slow = head
        while fast and fast.next:
            fast, slow = fast.next.next, slow.next
            if fast == slow:
                return True
        return False


```

### 142.环形链表II

需要返回环的入口，***存在的算法，当快慢指针在环中相遇的时候，将快指针放到起点每次走一步，快慢指针再次相遇的时候毕竟是在环的入口处。***

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            # 当快慢指针相遇的时候
            if fast is slow:
                fast = head
                while fast is not slow:
                    fast = fast.next
                    slow = slow.next
                return slow
        return None
```

### 143.链表重排

![image-20230914103625158](G:\Typora-user-images\image-20230914103625158.png)

![image-20230914103634128](G:\Typora-user-images\image-20230914103634128.png)

![image-20230914103607343](G:\Typora-user-images\image-20230914103607343.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def midNode(self, head:Optional[ListNode]) -> Optional[ListNode]:
        fast = head
        slow = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
    
    def reverseList(self, head:Optional[ListNode]) -> Optional[ListNode]:
        cur = head
        pre = None
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre

    def reorderList(self, head: Optional[ListNode]) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        mid = self.midNode(head)
        start2 = self.reverseList(mid)
        start1 = head
        while start2.next:# 唯一不明白的地方为什么这个地方是start2.next为空的时候终止条件
            #已经想明白了，因为第二条链要不就比第一条链长一个节点要不就一样长，因为中间节点划分给第二个链了
            nxt1 = start1.next
            nxt2 = start2.next
            start1.next = start2
            start2.next = nxt1
            start1 = nxt1
            start2 = nxt2
```

## 08.删除链表重复节点：

### 237.删除链表中的节点值

因为题目要求，只是删除链表节点的值就行，所以不一定非得移除链表值对应的节点，可以考虑将下一个节点的值copy过来，之后删除下一个节点

![image-20230914111924202](G:\Typora-user-images\image-20230914111924202.png)

### 19.删除链表的倒数第N个节点：

删除头节点一般是需要创建dammyNode

![image-20230914142228198](G:\Typora-user-images\image-20230914142228198.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # 由于本题有可能删除的是第一个节点，所以方便做法引入一个哨兵节点
        demmy = ListNode(next=head)
        # 首先初始第一个节点
        right = demmy
        for _ in range(n): # 让右指针到第n+1个节点的位置
            right = right.next
        # 此时初始化左指针，两个指针相聚为n，当右指针到达链表末尾的时候，左指针正好是倒数第n个节点的前一个节点，此时删除左指针后一个节点即可
        left = demmy
        while right.next:
            right = right.next
            left = left.next
        left.next = left.next.next
        return demmy.next
```

另一种方法：先寻找链表总长度，之后利用循环找到正序的删除节点，之后进行删除

### 83.删除排序链表中的重复元素

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return head

        cur = head
        while cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
```

### 82.删除排序链表中的重复元素II

![image-20230914151206105](G:\Typora-user-images\image-20230914151206105.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(next=head)
        cur = dummy
        while cur.next and cur.next.next:
            val = cur.next.val
            if cur.next.next.val == val:  
                while cur.next and cur.next.val == val: # while后面的判定条件是为了在删除了一个节点之后，判定是否还有val为相同值的节点，注意两个判定条件一定要一起写，否则cur.next.val会直接报错
                    cur.next = cur.next.next
            else:
                cur = cur.next
        return dummy.next
------------------------------------------------------------------------
class Solution(object):
    def deleteDuplicates(self, head):
        if head is None:
            return head
        demmy = ListNode(next=head)
        cur = demmy
        # 为防止第一个节点就是需要删除的节点，所以循环的cur从demmy开始，那么需要判断的就是cur.next和cur.next.next
        while cur.next and cur.next.next:
            val = cur.next.val
            if cur.next.next.val == val:# 验证需要删除当前值的所有节点
                while cur.next and cur.next.val == val: # 开始删除，只要是当前节点的值是为val，且节点不为空全部删除
                    cur.next = cur.next.next
            else:
                cur = cur.next
        return demmy.next
```

-------------

==2023年9月14日第一次复习以上内容==

---------

## 09.二叉树递归本质：

![image-20230915144343226](G:\Typora-user-images\image-20230915144343226.png)

边界条件：满足边界条件开始归

思考为什么这样做是对的，数学归纳法，只需要，递归就是系统帮忙压栈

### 104.二叉树的最大深度：

思路一，将原问题化成相似的子问题，递归函数定义，返回当前节点的最大深度，原问题就等于左右两个子树的最大深度加上自身（+1），这里要思考边界条件，如果函数超出叶节点，则return 0。

![image-20230915145030082](G:\Typora-user-images\image-20230915145030082.png)

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root: 
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```



另一种思路：设置一个全局变量，在每次递归都将全局变量加一，最后能得到最大的全局变量，就是答案。

![image-20230915145000922](G:\Typora-user-images\image-20230915145000922.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def dfs(root, nums): #nums参数计数在每次归的过程中会更新为上一级nums即（-1）
            if root is None:
                return 0
            nums += 1
            nonlocal ans #这里采用全局变量语句，否则会显示未赋值局部变量就调用，local variable 'ans' referenced before assignment
            ans = max(ans, nums)
            dfs(root.left, nums)
            dfs(root.right, nums)
        dfs(root, 0)
        return ans
```

## 10.如何灵活运用递归：

### 100.相同的树：

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

 思路一：化成子问题，原问题等于左右子树是否相同

![image-20230915150927830](G:\Typora-user-images\image-20230915150927830.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        # 递归的思路，寻找子问题，判断两棵树对应节点的左子树与右子树是否相同

        # 两棵树都是空树
        if p is None and q is None:
            return True
        # 两棵树一颗是空树一个不是空树，则一定不相同
        if (p == None and q != None) or (p != None and q == None):
            return False

        # 两棵树都不是空树，需要判断：
        # 根节点值不相等，一定不同
        if p.val != q.val:
            return False
        # 根节点值相同继续判断子节点
        
        Lefttree = self.isSameTree(p.left,q.left)
        Righttree = self.isSameTree(p.right,q.right)

        isSame = Lefttree and Righttree

        return isSame
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p is None or q is None:
            return p is q
        return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right, q.right)
```

### 101.对称二叉树：

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def dfs(q:Optional[TreeNode],p:Optional[TreeNode]):
            if q is None or p is None:
                return q is p
            return q.val == p.val and dfs(q.left,p.right) and dfs(q.right,p.left)
        return dfs(root.left, root.right)
```

### 110.平衡二叉树：

思路：这道题本质逻辑是从树的最大深度，通过剪枝进行判断，同时利用节点数不为负数，如果树不平衡将节点数返回为-1.

![image-20230915152947074](G:\Typora-user-images\image-20230915152947074.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def get_height(node:Optional[TreeNode]):
            if node is None :
                return 0
            left_height = get_height(node.left)
            # 剪枝如果不平衡返回-1
            if left_height == -1:
                return -1
            right_height = get_height(node.right)
            if right_height == -1 or abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1
        return get_height(root) != -1
```

### 199.二叉树的右视图：

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

![image-20230915161249246](G:\Typora-user-images\image-20230915161249246.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        def dfs(node:Optional[TreeNode], cnt:int):
            if node is None:
                return 
            if len(res) == cnt:
                res.append(node.val)
            cnt += 1 #代表树的深度，如果树的深度和放入res中的元素相同代表能看到
            dfs(node.right, cnt) #先右后左，进行递归，不要想太多
            dfs(node.left, cnt)
        dfs(root, 0)
        return res
```

## 11.验证二叉搜索树：

二叉搜索树：所有左子树的节点值，都小于右子树的节点值 

### *98.验证二叉搜索树：

1.前序遍历：

![image-20230915162344010](G:\Typora-user-images\image-20230915162344010.png)

![image-20230915162125521](G:\Typora-user-images\image-20230915162125521.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidBST(self, root: Optional[TreeNode], left = -inf, right = inf) -> bool:
        if root is None:
            return True
        x = root.val
        return left < x < right and self.isValidBST(root.left, left, x) and self.isValidBST(root.right, x, right)
```

2.中序遍历：二叉搜索树严格递增

![image-20230915162610329](G:\Typora-user-images\image-20230915162610329.png)

## 12.二叉树公共祖先问题：

### 236.二叉树的最近公共祖先：

![image-20230915200143336](G:\Typora-user-images\image-20230915200143336.png)

情况一：递归中找到了其中一个不需要继续递归，直接返回本身

![image-20230915200259097](G:\Typora-user-images\image-20230915200259097.png)

左右子树都找到了节点，直接返回当前节点

![image-20230915200342583](G:\Typora-user-images\image-20230915200342583.png)

左子树找到了，右子树没有找到，返回左子树中寻找公共祖先

![image-20230915200416095](G:\Typora-user-images\image-20230915200416095.png)

![image-20230915200443123](G:\Typora-user-images\image-20230915200443123.png)

![image-20230915200605813](G:\Typora-user-images\image-20230915200605813.png)

```python
"""
思路：
递归函数的意义：返回根节点子树中p,q的最近共公祖先
边界条件：
root节点为None或root节点为p或q节点，三种情况都能证明此时root为最近公共祖先
其他条件：
p和q出现在同一子树中，继续对这一子树进行递归；p和q出现在根节点两侧时，直接返回当前根节点。

"""
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # 边界条件
        if root is None or root is p or root is q:
            return root
        # 如果没达到最终的条件
        # 进行迭代分别在左右子树中寻找p和q的公共根节点
        left_root = self.lowestCommonAncestor(root.left, p, q)
        right_root = self.lowestCommonAncestor(root.right, p, q)
        # 此时有两种情况，一种一个迭代为空，证明p和q节点都在另一个子树中，第二种：left_root和right_root都不为空，此时根节点为最近公共祖先
        if left_root and right_root:
            return root
        if left_root:
            return left_root
        return right_root
```



### 235.二叉搜索树的最近公共祖先：

![image-20230915201027255](G:\Typora-user-images\image-20230915201027255.png)

为什么边界条件不用判断空节点：题目中说明p，q为不同节点且均存在于给定的二叉搜索树中，所以在找到公共祖先的过程中不会出发到节点为空的边界条件，所以可以设置其余的边界条件。

对于二叉搜索树的公共祖先问题比一般树的问题要简单，可以利用左侧子树值都小于根节点，右侧子树值都大于根节点的性质。

![image-20230915201125072](G:\Typora-user-images\image-20230915201125072.png)

```python
"""思考方式：如果当前节点就是p或q节点，那么直接返回当前节点，如果都在左或右子树，则继续进行递归，如果在两个子树则返回当前节点"""
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        x = root.val
        if p.val < x and q.val < x:
            return self.lowestCommonAncestor(root.left,p,q) #思考为什么直接将递归函数放在return后面，因为本次递归没有写边界条件，不写return不行。
        if p.val > x and q.val > x:
            return self.lowestCommonAncestor(root.right,p,q)
        return root
```

## 13.二叉树的层序遍历：

### 102.二叉树的层序遍历：

双数组写法：利用两个数组，cur和nxt一层存放当前层有的所有节点，通过在当前层for循环遍历，将当前层所有的子节点放到nxt数组中，反复传递达到叶节点。

![image-20230915204829656](G:\Typora-user-images\image-20230915204829656.png)

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        cur = []
        if root is None:
            return []
        cur.append(root)
        while cur: #注意边界条件，每次都是将cur下面的子节点赋给nxt中，当cur为叶节点时，nxt为完全空数组，此时再赋给cur中后循环终止。
            nxt = []
            res = []
            for cur_one in cur:
                res.append(cur_one.val)
                if cur_one.left:  nxt.append(cur_one.left)
                if cur_one.right: nxt.append(cur_one.right)
            cur = nxt
            ans.append(res)
        return ans
```

队列写法：相当于将cur和nxt两个数组合并。

注意：如何确定每一层循环的次数，循环的次数即在每层循环开始前将对列长度进行记录，循环队列长度次即可。

![image-20230915211251503](G:\Typora-user-images\image-20230915211251503.png)

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        q = deque([root]) #双端队列的写法
        if root is None:
            return []
        while q:
            res = []
            for _ in range(len(q)):
                node = q.popleft() #队列首端弹出的写法
                res.append(node.val)
                if node.left:  q.append(node.left)
                if node.right: q.append(node.right)
            ans.append(res)
        return ans
```

### 103.二叉树的锯齿形层序遍历：

![image-20230915212028494](G:\Typora-user-images\image-20230915212028494.png)

```python
class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        cur = []
        if root is None:
            return []
        cur.append(root)
        even = False
        while cur: #注意边界条件，每次都是将cur下面的子节点赋给nxt中，当cur为叶节点时，nxt为完全空数组，此时再赋给cur中后循环终止。
            nxt = []
            res = []
            for cur_one in cur:
                res.append(cur_one.val)
                if cur_one.left:  nxt.append(cur_one.left)
                if cur_one.right: nxt.append(cur_one.right)
            cur = nxt
            ans.append(res[::-1] if even else res)
            even = not even
        return ans
```

### 513.找树左下角的值：

```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        cur = []
        if root is None:
            return []
        cur.append(root)
        res = []
        while cur: #注意边界条件，每次都是将cur下面的子节点赋给nxt中，当cur为叶节点时，nxt为完全空数组，此时再赋给cur中后循环终止。
            nxt = []
            res = cur[0]
            for cur_one in cur:
                if cur_one.left:  nxt.append(cur_one.left)
                if cur_one.right: nxt.append(cur_one.right)
            cur = nxt
        return res.val
```

第二种思路：将层序遍历改成从右向左，这样最后一层最后一个节点值就是我们要求的节点，只需要将最后的值返回即可得到答案。

![image-20230915212758395](G:\Typora-user-images\image-20230915212758395.png)

## 14.回溯算法套路——子集型回溯：

![image-20230916105855664](G:\Typora-user-images\image-20230916105855664.png)

![image-20230916110010675](G:\Typora-user-images\image-20230916110010675.png)

不要想太多，边界条件和非边界条件写对，其余交给数学归纳法：

![image-20230916110049225](G:\Typora-user-images\image-20230916110049225.png)

i的含义不是第i个而是大于等于i的部分需要枚举

### 17.电话号码的字母组合：

````python
MAPPING = ['','','abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        n = len(digits)
        result = []
        path = []
        if n == 0:
            return []
        def dfs(i):#i的含义，第i个digits的元素，dfs的含义用前i个数字所对应的字母，能组合出多少种满足要求的组合。
            if i == n:
                result.append(''.join(path))
                return 
            for lab in MAPPING[int(digits[i])]:
                path.append(lab)
                dfs(i + 1)
                path.pop()
        dfs(0)
        return result
````

### 78.子集

![image-20230916111834542](G:\Typora-user-images\image-20230916111834542.png)

![image-20230916111941869](G:\Typora-user-images\image-20230916111941869.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        n = len(nums)

        def dfs(i:int): 
            if i == n:
                res.append(path.copy())
                return 
            # 此回溯只有两种选项，是二叉树类型的，所以不用添加for循环，添加for循环可以形成多叉型的树结构
            # 这样写的目的，先左后右（先不选再选），都需要遍历，
            dfs(i+1)

            path.append(nums[i])
            dfs(i+1)
            path.pop()
        dfs(0)
        return res
```

**another way of thinking**

![image-20230916112655077](G:\Typora-user-images\image-20230916112655077.png)

![image-20230916112713301](G:\Typora-user-images\image-20230916112713301.png)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        n = len(nums)
        # 回溯每次从nums中循环选择，i代表从0开始逐次从头开始选择
        def dfs(i:int): #dfs含义第i个元素及其之后的元素所能共同组成的子集
            res.append(path.copy()) #因为对于递归的节点长度没有要求了，所以对于每个path都应该记录
            if i == n:
                return 
            for j in range(i,n): # 从上图中可以看出for循环相当于几叉树，i代表的是选的第几个数
                path.append(nums[j])
                dfs(j+1) #为什么是j，因为不能重复所以在选完j之后要从j之后的节点进行递归
                path.pop()
        dfs(0)
        return res
```

### *131.分割回文串：

![image-20230916113817108](G:\Typora-user-images\image-20230916113817108.png)

![image-20230916114951531](G:\Typora-user-images\image-20230916114951531.png)

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def is_reserve_str(s:str) -> bool:
            n = len(s)
            if n == 0:
                return False
            right = n - 1
            left = 0
            while right > left:
                if s[left] == s[right]:
                    right -= 1
                    left += 1
                else:
                    return False
            return True
        
        res = []
        path = []
        n = len(s)
        if n == 0:
            return []
        def dfs(i):
            if i == n:
                res.append(path.copy())
                return 
            for j in range(i, n):
                if is_reserve_str(s[i:j+1]): #注意为什么是j+1，因为切片的尾数切不到
                    path.append(s[i:j+1])
                    dfs(j + 1)
                    path.pop()
        dfs(0)
        return res
```

## 15.回溯算法套路——组合型回溯+剪枝

### 77.组合：

![image-20230916115511929](G:\Typora-user-images\image-20230916115511929.png)

![image-20230920120247204](G:\Typora-user-images\image-20230920120247204.png)

![image-20230920120033675](G:\Typora-user-images\image-20230920120033675.png)

![image-20230916115941123](G:\Typora-user-images\image-20230916115941123.png)

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        path = []
        def back_track(n, k, startindex):
            if len(path)==k:
                result.append(path.copy())
                return
            
            # 单层搜素的逻辑
            for i in range(startindex,n+1):
                path.append(i)
                back_track(n, k, i+1)
                path.pop()
        back_track(n, k, 1)
        return result
```

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        nums = [i for i in range(1, n+1)]
        res = []
        path = []
        def dfs(i):
            # 进行剪枝：如果当前选的值i，剩余未选的数的个数为n-i，需要继续选取的数为k-len(path),如果n-i < k-len(path),直接剪枝
            if k - len(path) > n - i + 1: #为什么要+1，要算上自身
                return
            if len(path) == k:
                res.append(path.copy())
                return
            # 单层搜素逻辑
            for j in range(i, n + 1):
                path.append(j)
                dfs(j + 1)
                path.pop()
        dfs(1)
        return res
```



### 216.组合总数III：

![image-20230916122848497](G:\Typora-user-images\image-20230916122848497.png)

==优化代码还没尝试明白==

![image-20230916123438557](G:\Typora-user-images\image-20230916123438557.png)

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        choices = [i for i in range(1, 10)]
        res = []
        path = []

        def dfs(i):
            if sum(path) == n and len(path) == k:
                res.append(path.copy())
                return 
            # ==剪枝==
            if (9-i) + len(path) < 3:
                return
            if sum(path) > n:
                return
            for j in range(i, 9):
                path.append(choices[j])
                dfs(j+1)
                path.pop()
        dfs(0)
        return res
```

### *22.括号生成：

![image-20230916123811622](G:\Typora-user-images\image-20230916123811622.png)

![image-20230916123628713](G:\Typora-user-images\image-20230916123628713.png)

![image-20230916123733928](G:\Typora-user-images\image-20230916123733928.png)

![image-20230916125242468](G:\Typora-user-images\image-20230916125242468.png)

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 思路梳理:一共有2n个位置防止括号，左括号必须先放，才能放右括号，i代表放置的第i个括号，j代表左括号的个数。
        #主要运用选或不选的代码思路，不选就是放左括号，选就是放右括号。
        res = []
        path = []
        def dfs(i, j):
            if i == 2 * n:
                res.append(''.join(path))
                return
            if j < n: #为什么能放左括号就放左括号
                path.append('(')
                dfs(i+1, j+1)
                path.pop()
            if i < 2 * j:
                path.append(')')
                dfs(i+1, j)
                path.pop()
        dfs(0,0)
        return res
```

### 301.删除无效的括号：



## 16.回溯算法套路——排列型回溯+N皇后

![image-20230916125349643](G:\Typora-user-images\image-20230916125349643.png)

### 46.全排列：

**如何确定剩余可以选的数字**，通过添加一个集合记录剩余数字的方法。

![image-20230916125447284](G:\Typora-user-images\image-20230916125447284.png)

![image-20230916125736802](G:\Typora-user-images\image-20230916125736802.png)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        # 梳理思路：本题难点需要将递归之后可以选择的数字进行记录，让下次递归的过程中在没有重复元素的集合中进行选取。
        res = []
        path = []
        n = len(nums)
        def dfs(i, set1):
            if i == n:
                res.append(path.copy())
                return
            
            for j in set1:
                path.append(j)
                dfs(i+1, set1-{j})
                path.pop()
        
        dfs(0,set(nums))
        return res
```

![image-20230916132756097](G:\Typora-user-images\image-20230916132756097.png)

![image-20230916132733458](G:\Typora-user-images\image-20230916132733458.png)



### *51.N皇后问题：

![image-20230916132954739](G:\Typora-user-images\image-20230916132954739.png)

![image-20230916133020050](G:\Typora-user-images\image-20230916133020050.png)

![image-20230916133713074](G:\Typora-user-images\image-20230916133713074.png)



## 17.动态规划：

![image-20230916134831520](G:\Typora-user-images\image-20230916134831520.png)

### 198.打家劫舍：

![image-20230916134957672](G:\Typora-user-images\image-20230916134957672.png)

![image-20230916150126063](G:\Typora-user-images\image-20230916150126063.png)

![image-20230916150235394](G:\Typora-user-images\image-20230916150235394.png)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
    # 递归的解法，首先思考dfs（i）含义，在偷*到*第i个所能获得的最大利润
        n = len(nums)
        @cache #cache必须放在def的上面一行，会将递归函数调用的参数的值进行记录
        def dfs(i):
            if i < 0:
                return 0
            res = max(dfs(i-1), dfs(i-2) + nums[i])
            return res
        return dfs(n -1)
```

使用数组的方法

![image-20230916150311619](G:\Typora-user-images\image-20230916150311619.png)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
    # 递归的解法，首先思考dfs（i）含义，在偷*到*第i个所能获得的最大利润
        n = len(nums)
        res = 0
        cache = [-1] * n
        def dfs(i):
            if i < 0:
                return 0
            if cache[i] != -1:
                return cache[i]
            res = max(dfs(i-1), dfs(i-2) + nums[i])
            cache[i]= res
            return res
        return dfs(n -1)
```

**动态规划写法**

![image-20230916150423122](G:\Typora-user-images\image-20230916150423122.png)

![image-20230916150628378](G:\Typora-user-images\image-20230916150628378.png)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
    # 递归的解法，首先思考dfs（i）含义，在偷*到*第i个所能获得的最大利润
        n = len(nums)
        dp = [0] * (n + 2)
        for i in range(0, n):
            dp[i + 2] = max(dp[i + 1], dp[i] + nums[i])
        return dp[n + 1]
```

更新优化空间复杂度：可知当前计算只与前两个i-1和i-2有关，可用三个参数代替数组。

![image-20230916150706728](G:\Typora-user-images\image-20230916150706728.png)

## 18.0-1背包 完全背包：

![image-20230916154109640](G:\Typora-user-images\image-20230916154109640.png)

![image-20230916185646644](G:\Typora-user-images\image-20230916185646644.png)

恰好装就是要把max改成+

![image-20230916185753889](G:\Typora-user-images\image-20230916185753889.png)

### 494.目标和：

![image-20230916185915350](G:\Typora-user-images\image-20230916185915350.png)

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        # 通过递归思想写，dfs(i:第i个物品,c：背包剩余容量)本题求等于目标容量的方法个数，所以dfs函数的意义是填满容量为c的背包用前i个物品的方法有多少个，本题是组合所以要区别相同元素不同循序的情况。
        # dfs(i, c)= dfs(i-1,c)# 不装第i个 + dfs(i-1,c-nums[i])# 装第i个
        # 根据题意进行解释
        if (target+sum(nums))%2 != 0 or target + sum(nums) < 0 :
            return 0
        num1=int((target+sum(nums))/2)
        n = len(nums)

        @cache
        def dfs(i, c):
            if i < 0:
                return 1 if c == 0 else 0
            if c < nums[i]:
                return dfs(i-1, c)
            return dfs(i-1, c) + dfs(i-1, c-nums[i])
        return dfs(n-1, num1)
```

![image-20230916192838248](G:\Typora-user-images\image-20230916192838248.png)

#### 两个数组的写法：

![image-20230916193007216](G:\Typora-user-images\image-20230916193007216.png)

#### 一个数组：

需要倒序写01背包：

![image-20230916193131095](G:\Typora-user-images\image-20230916193131095.png)

完全背包：

和01背包最大的区别，递归不是i-1而是可以继续递归i

![image-20230916193144921](G:\Typora-user-images\image-20230916193144921.png)

### 322.零钱兑换：

递归代码：

![image-20230918152134741](G:\Typora-user-images\image-20230918152134741.png)

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # dfs(i, c)使用前i个种类的硬币，装满容量为c的背包，最少硬币个数
        # dfs(i, c) = min(dfs(i-1, c), dfs(i,c-amount[i])+1)
        n = len(coins)

        @cache
        def dfs(i, c):
            if i < 0:
                return 0 if c == 0 else inf #返回无穷大代表不合法，在取最小值的时候也会把这种情况舍弃掉
            if c < coins[i]:
                return dfs(i-1, c)
            return min(dfs(i-1, c), dfs(i, c-coins[i]) + 1)
        ans = dfs(n -1 , amount)
        return ans if ans < inf else -1
```

递推代码：

![image-20230916193354613](G:\Typora-user-images\image-20230916193354613.png)

```python
# 改为递推代码：
        # dp[i, c]的含义，在用前i种硬币装满容量为c的背包，最少需要多少个
        # dp[i, c] = min(dp[i-1, c], dp[i, c-coins[i]] + 1)
        n = len(coins)
        dp = [[inf] * (amount + 1) for _ in range(n + 1)] #容量从0~amount共amount+1个数，n同理从0~n共n+1个数
        dp[0][0] = 0
        for i, x in enumerate(coins):
            for c in range(amount+1):
                if c < x:
                    dp[i+1][c] = dp[i][c]
                else:
                    dp[i+1][c] = min(dp[i][c], dp[i+1][c-x] + 1)
        ans = dp[n][amount]
        return ans if ans < inf else -1
```



```python
# 装满容量为amount的背包所需要最少的物品数
        dp = [amount+1]*(amount+1)

        # 初始化，因为本题是min，所以不能全都初始化为零，要不然在min中全都将取0
        dp[0]=0

        for i in range(0,len(coins)):
            for j in range(coins[i],amount+1): # 完全背包用一个数组不需要从后往前遍历
                dp[j]=min(dp[j],dp[j-coins[i]]+1)
        if amount==0:
            return 0
        if dp[amount]==(amount+1):
            return -1

        return dp[amount]
```

## 19.最长公共子序列 编辑距离：

![image-20230918154345982](G:\Typora-user-images\image-20230918154345982.png)

### 1143.最长公共子序列：

不是说算法想不明白，是题目的流程想不明白

![image-20230918162300552](G:\Typora-user-images\image-20230918162300552.png)

![image-20230918162335056](G:\Typora-user-images\image-20230918162335056.png)

![image-20230918162820076](G:\Typora-user-images\image-20230918162820076.png)

![image-20230918162735648](G:\Typora-user-images\image-20230918162735648.png)

```python
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        #dfs(i, j)text1的第i个字母和text2的前j个字母所拥有的公共子序列最大长度。
        # 如果text1[i] == text2[j] 都应该选上，只选其中一个
        # 如果text1[i] !=text2[j] 都不选，只选其中一个
        n = len(s)
        m = len(t)

        @cache
        def dfs(i, j):
            if i < 0 or j < 0:
                return 0
            if s[i] == t[j]:
                return dfs(i-1,j-1) + 1
            return max(dfs(i-1, j), dfs(i, j-1))
        return dfs(n-1, m-1)
```

改成递推：

```python
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        #dp[i][j]text1的第i个字母和text2的前j个字母所拥有的公共子序列最大长度。
        # 如果text1[i] == text2[j] 都应该选上，只选其中一个
        # 如果text1[i] !=text2[j] 都不选，只选其中一个
        n = len(s)
        m = len(t)
        dp = [[0] * (m + 1) for _ in range(n + 1)] # 为什么是n+1 和m+1 因为存在0~n种情况共是n+1个数
        for i in range(1, n + 1):
            for j in range(1, m + 1):
                if s[i-1] == t[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        return dp[n][m]
```

![image-20230919165515103](G:\Typora-user-images\image-20230919165515103.png)

空间优化：

![image-20230919170019615](G:\Typora-user-images\image-20230919170019615.png)

### 72.编辑距离：

![image-20230919170108090](G:\Typora-user-images\image-20230919170108090.png)

![image-20230919170233703](G:\Typora-user-images\image-20230919170233703.png)

![image-20230919170246363](G:\Typora-user-images\image-20230919170246363.png)

![image-20230919170320756](G:\Typora-user-images\image-20230919170320756.png)

## 20.最长递增子序列：

![image-20230918215006699](G:\Typora-user-images\image-20230918215006699.png)

回溯从最后开始考虑，两种思路，选或不选，枚举选哪个——从最后出发枚举比最后小的元素，返回下标。

![image-20230918215206247](G:\Typora-user-images\image-20230918215206247.png)

![image-20230918215419543](G:\Typora-user-images\image-20230918215419543.png)

![image-20230918215558815](G:\Typora-user-images\image-20230918215558815.png)

![image-20230918215651415](G:\Typora-user-images\image-20230918215651415.png)

 ## 21.买卖股票的最佳时间：无限次/冷冻期/k次：

- [ ] 第一次复习

- [ ] 第二次复习

- [ ] 第三次复习

![image-20230919094945973](G:\Typora-user-images\image-20230919094945973.png)

### 122.买卖股票的最佳时机II（不限交易次数）

解：主要是dfs/dp数组的含义，定义成第i天结束时持有股票所获得的最大利润，和第i天结束时不持有股票所能获得的最大利润，所以是二维数组。对于不可能存在的情况一般是根据取max，还是min设置成inf或-inf

![image-20230919101533574](G:\Typora-user-images\image-20230919101533574.png)

![image-20230919101908439](G:\Typora-user-images\image-20230919101908439.png)

![image-20230919102459501](G:\Typora-user-images\image-20230919102459501.png)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #dfs(i, False)第i天结束时，未持有股票的利润
        #dfs(i, Hold)第i天结束时，持有股票的利润
        n = len(prices)
        @cache
        def dfs(i, hold):
            if i < 0:
                return 0 if not hold else -inf #总是边界条件想不清楚，i==0对应的price的第一个元素，如果边界条件写i==0，则price[i-1],递归入口从dfs（n，False），最好还是使用i<0边界条件，这样可以应对集合为空的情况
            if hold:
                return max(dfs(i-1, True), dfs(i-1, False) - prices[i])
            else: 
                return max(dfs(i-1, False), dfs(i-1, True) + prices[i])
        return dfs(n - 1, False)
    
    ----------------------------------------------------------
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        #dfs(i, False)第i天结束时，未持有股票的利润
        #dfs(i, Hold)第i天结束时，持有股票的利润
        n = len(prices)
        @cache
        def dfs(i, hold):
            if i == 0:
                return 0 if not hold else -inf
            if hold:
                return max(dfs(i-1, True), dfs(i-1, False) - prices[i-1])
            else: 
                return max(dfs(i-1, False), dfs(i-1, True) + prices[i-1])
        return dfs(n , False)
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        n = len(prices)
        dp = [[0] * (n + 1) for _ in range(2)]
        #dp[0][i]表示不持有股票所有的最大利润
        #dp[1][i]表示第i天持有股票所有的最大利润
        dp[0][0] = 0
        dp[1][0] = -inf
        for i in range(1, n + 1):
            dp[0][i] = max(dp[0][i-1], dp[1][i-1] + prices[i-1])
            dp[1][i] = max(dp[1][i-1], dp[0][i-1] - prices[i-1])
        return dp[0][n]
```

```python
        # 进行空间优化：
        # 后一天只与前一天有关系
        n = len(prices)
        dp = [0]*2
        temp = 0
        #dp[0][i]表示不持有股票所有的最大利润
        #dp[1][i]表示第i天持有股票所有的最大利润
        dp[0] = 0
        dp[1] = -inf
        for i in range(1, n + 1):
            temp = dp[0]
            dp[0] = max(dp[0], dp[1] + prices[i-1])
            dp[1] = max(dp[1], temp - prices[i-1])
        return dp[0]
```

### 309.最佳买卖股票时机含冷冻期：

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 用递推写：
        n = len(prices)
        dp = [[0] * (n + 1) for _ in range(2)]
        #dp[0][i]表示不持有股票所有的最大利润
        #dp[1][i]表示第i天持有股票所有的最大利润
        dp[0][0] = 0
        dp[1][0] = -inf
        dp[0][1] = 0
        dp[1][1] = -prices[0]
        for i in range(2, n + 1):
            dp[0][i] = max(dp[0][i-1], dp[1][i-1] + prices[i-1])#题目要求买入股票后第二天能卖
            dp[1][i] = max(dp[1][i-1], dp[0][i-2] - prices[i-1])
        return dp[0][n]
```

### 188.买卖股票的最佳时机IV：

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        #递归方法
        n = len(prices)
        # dfs(i,hold)表示第i天持有或不持有股票的利润
        # dfs(i,hold)=max(dfs(i-1,hold),dfs(i-1,unhold)-price[i])
        # dfs(i,unhold)=max(dfs(i-1,unhold),dfs(i-1,hold)+price[i])
        # 边界条件
        # dfs(0,unhold)=0
        # dfs(0,hold)=-inf
        @cache
        def dfs(i:int, hold:bool, k):
            if i < 0:
                return -inf if hold else 0
            if k < 0:
                return -inf
            if hold:
                return max(dfs(i-1, True, k), dfs(i-1, False, k) - prices[i])
            return max(dfs(i-1, False, k), dfs(i-1, True, k-1) + prices[i]) #买卖算一次，只能买完算使用一次交易次数，所以要将k-1写在卖的时候
        return dfs(n-1, False, k)
```

![image-20230919112135335](G:\Typora-user-images\image-20230919112135335.png)

![image-20230919112703101](G:\Typora-user-images\image-20230919112703101.png)



```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        # dp[i][bool][j]在第i天结束时买入或卖出剩余交易次数为j时对应的最大利润，三维数组，尽量不要结合数学几何思维，就考虑不同维度代表的含义，比如说最绕的是j所在维度，如果j为0代表的是没有进行一次交易，所以此时是合法的利润应设置为0
        n = len(prices)
        dp = [[[-inf ] * (k + 1) for _ in range(2)] for _ in range(n + 1)]
        for j in range(0, k+1):
            dp[0][0][j] = 0
        for j in range(1, n+1):#边界条件一定要想清楚，当交易次数为零的时候是说明一次也没有进行买卖，此时为0
            dp[j][0][0] = 0
            dp[j][1][0] = 0
        for i in range(1,n+1):
            for j in range(1, k+1):
                dp[i][0][j] = max(dp[i-1][0][j], dp[i-1][1][j] + prices[i-1])
                dp[i][1][j] = max(dp[i-1][1][j], dp[i-1][0][j-1] - prices[i-1])#必须卖出了之后才算是完成一次交易
        return dp[n][0][k]
```

## 22.区间DP：最长回文子序列 最优三角部分：

![image-20230919141210794](G:\Typora-user-images\image-20230919141210794.png)

### 516.最长回文子序列：

![image-20230919141259368](G:\Typora-user-images\image-20230919141259368.png)

![image-20230919141348630](G:\Typora-user-images\image-20230919141348630.png)

![image-20230919141418473](G:\Typora-user-images\image-20230919141418473.png)

![image-20230919141510472](G:\Typora-user-images\image-20230919141510472.png)

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        # dfs(i, j)从i到j的字符串中回文子串数量
        n = len(s)
        @cache
        def dfs(i, j):
            if i > j:
                return 0
            if i == j:
                return 1
            if s[i] == s[j]:
            	return dfs(i+1, j-1) + 2
            return max(dfs(i+1, j), dfs(i, j-1))
        return dfs(0, n-1)
```



![image-20230919141546085](G:\Typora-user-images\image-20230919141546085.png)

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        # 递推/动态规划
        # dp[i,j]i，j中的回文子串的最长数量
        # dp[i][j] = max(dp[i+1][j],dp[i][j-1])      s[i]!=s[j]
        # dp[i][j] = dp[i+1][j-1]+2                  s[i]==s[j]
        n = len(s)
        dp = [[0]*n for i in range(n)]
        for i in range(n-1,-1,-1):
            dp[i][i]=1
            for j in range(i+1,n):                    
                if s[i] != s[j]:
                    dp[i][j] = max(dp[i+1][j],dp[i][j-1])
                else:
                    dp[i][j] = dp[i+1][j-1]+2
        return dp[0][n-1]
```

### 1039.多边形三角剖分的最低得分：

![image-20230919142228513](G:\Typora-user-images\image-20230919142228513.png)

![image-20230919142237564](G:\Typora-user-images\image-20230919142237564.png)

![image-20230919142314085](G:\Typora-user-images\image-20230919142314085.png)

```python
class Solution:
    def minScoreTriangulation(self, values: List[int]) -> int:
        # dfs（i， j）从i，到j的最低得分划分子问题dfs（i，k）
        # dfs(i, j) = min（res， dfs(i, k) + dfs(k, j) + v[i]*v[j]*v[k]）
        n = len(values)
        @cache
        def dfs(i, j):
            if i+1 == j:
                return 0
            res = inf
            for k in range(i+1, j):
                res = min(res, dfs(i, k) + dfs(k, j) + values[i]*values[k]*values[j])
            return res
        return dfs(0, n-1)
```

![image-20230919142409177](G:\Typora-user-images\image-20230919142409177.png)

```python
# dp[i][j]从i，j的最低得分
        # dp[i][j]=min(dp[])
        n = len(values)
        dp = [[0] * n for _ in range(n)]
        for i in range(n-3, -1, -1):
            for j in range(i+2, n):
                res = inf 
                for k in range(i+1, j):
                    res = min(res, dp[i][k] +dp[k][j]+ values[i]*values[j]*values[k])
                dp[i][j]=res
        return dp[0][n-1]
```

## 23.树形DP-树的直径：

![image-20230918121525075](G:\Typora-user-images\image-20230918121525075.png)

### 543.二叉树的直径：

![image-20230918121632815](G:\Typora-user-images\image-20230918121632815.png)

![image-20230918121818376](G:\Typora-user-images\image-20230918121818376.png)

![image-20230918121937919](G:\Typora-user-images\image-20230918121937919.png)

![image-20230918122009974](G:\Typora-user-images\image-20230918122009974.png)

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans = 0 #用来记录二叉树的直径
        def dfs(node:TreeNode): # dfs定义当前节点左右子树的最大深度,这样可以进行问题的递推。
            if node is None:
                return -1# 为什么边界条件设置为-1，因为当当前节点为空节点时，其左右子树深度都为0，且当前节点与左右子树相连的深度也没有，默认是有的所以返回-1.
            # 中间逻辑：1原问题等于子问题加上
            left_depth = dfs(node.left)
            right_depth = dfs(node.right)
            nonlocal ans
            ans = max(ans, left_depth +right_depth +2)
            return max(left_depth, right_depth) + 1
        dfs(root)
        return ans
```

### 124.二叉树中的最大路径和：

![image-20230918122216683](G:\Typora-user-images\image-20230918122216683.png)

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = -inf #用来记录二叉树的最大路径和
        def dfs(node:TreeNode): # dfs定义当前节点左右子树的最大链和
            if node is None:
                return 0
            # 中间逻辑：1原问题等于子问题加上
            left_val = dfs(node.left)
            right_val = dfs(node.right)
            nonlocal ans
            ans = max(ans, left_val +right_val +node.val)
            return max(max(left_val, right_val) + node.val, 0)#如果整条路径小于零，那么就取空节点，不一定非得取到头
        dfs(root)
        return ans
```

### 2246.*相邻字符不同的最长路径：

![image-20230918143228904](G:\Typora-user-images\image-20230918143228904.png)

## 24.树形DP-打家劫舍III：

### 337.打家劫舍III

![image-20230918143243584](G:\Typora-user-images\image-20230918143243584.png)

![image-20230918143601971](G:\Typora-user-images\image-20230918143601971.png)

![image-20230918143736643](G:\Typora-user-images\image-20230918143736643.png)

```python
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        # dfs含义选， 不选当前节点及其子树时的最大值
        def dfs(node):
            if node is None:
                return 0, 0
            l_rob, l_not_rob = dfs(node.left)
            r_rob, r_not_rob = dfs(node.right)
            # 当前节点的最大值，等于不选当前节点时
            cur_not_rob = max(l_rob, l_not_rob) + max(r_not_rob, r_rob)
            cur_rob = l_not_rob + r_not_rob + node.val
            return cur_rob, cur_not_rob
        return max(dfs(root))
```

![image-20230918150226589](G:\Typora-user-images\image-20230918150226589.png)

## 25.树形DP：监控二叉树

### 968.监控二叉树：





## 结课时间：

9月22号之前完成复习：

必须要完全学明白一套课程才是真的对自身有提高。
